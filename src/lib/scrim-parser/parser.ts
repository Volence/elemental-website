/**
 * ScrimTime log file parser.
 * Reads .txt CSV files generated by the ScrimTime workshop code and
 * converts them into structured ParserData objects.
 *
 * Ported from parsertime (MIT license) — adapted to remove xlsx dependency
 * and framework-specific code (NextAuth, Prisma imports). This is pure
 * data transformation with no side effects.
 */

import { headers } from './headers'
import type { ParserData } from './types'

/** Valid Overwatch 2 map types from ScrimTime logs */
const VALID_MAP_TYPES = new Set([
  'Control', 'Escort', 'Hybrid', 'Push', 'Flashpoint', 'Clash',
])

/**
 * Validate that a file's content looks like a ScrimTime log.
 * Checks multiple signatures unique to dkeeh's workshop code output:
 *  1. A meaningful percentage of lines have recognized event types
 *  2. A match_start event exists with the correct column count
 *  3. The map_type field is a real OW2 game mode
 *  4. player_stat events exist (always present in valid logs)
 *
 * @returns null if valid, or a human-readable error string if invalid
 */
export function validateScrimLog(fileContent: string): string | null {
  const rawLines = fileContent.split('\n').filter((l) => l.trim().length > 0)

  if (rawLines.length < 5) {
    return 'File is too short to be a ScrimTime log (fewer than 5 lines).'
  }

  // Split into CSV and shift off the timestamp column (column 0)
  const lines = rawLines.map((l) => {
    const cols = l.split(',')
    cols.shift() // remove timestamp
    return cols
  })

  // 1. Check that a meaningful percentage of lines have recognized event types
  let recognizedCount = 0
  for (const line of lines) {
    if (headers[line[0]]) recognizedCount++
  }
  const recognizedPct = recognizedCount / lines.length
  if (recognizedPct < 0.5) {
    return (
      `This doesn't appear to be a ScrimTime log file. ` +
      `Only ${Math.round(recognizedPct * 100)}% of lines contain recognized event types ` +
      `(expected: kill, player_stat, hero_spawn, match_start, etc.). ` +
      `Make sure you're uploading the .txt file exported from the ScrimTime workshop code.`
    )
  }

  // 2. Find match_start events
  const matchStarts = lines.filter((l) => l[0] === 'match_start')
  if (matchStarts.length === 0) {
    return (
      'No match_start event found. A valid ScrimTime log must contain at least one match_start line ' +
      'with map name, map type, and team names.'
    )
  }

  // 3. Validate match_start column count (should be 6: event_type, match_time, map_name, map_type, team1, team2)
  for (const ms of matchStarts) {
    if (ms.length < 6) {
      return (
        `match_start event has ${ms.length} columns (expected 6). ` +
        `This file may be from an incompatible workshop code version.`
      )
    }
  }

  // 4. Validate map_type is a real OW2 game mode
  const mapType = matchStarts[0][3]?.trim()
  if (mapType && !VALID_MAP_TYPES.has(mapType)) {
    return (
      `Unrecognized map type "${mapType}" in match_start event. ` +
      `Expected one of: ${Array.from(VALID_MAP_TYPES).join(', ')}. ` +
      `This file may not be from the ScrimTime workshop code.`
    )
  }

  // 5. Check for player_stat events (always present in valid logs)
  const hasPlayerStats = lines.some((l) => l[0] === 'player_stat')
  if (!hasPlayerStats) {
    return (
      'No player_stat events found. A complete ScrimTime log should contain player stat snapshots. ' +
      'The match may have ended prematurely or the file is truncated.'
    )
  }

  return null // Valid
}

/**
 * Parse a ScrimTime .txt log file into structured event data.
 *
 * The ScrimTime workshop code outputs CSV-formatted lines where:
 * - Column 0: timestamp (ignored — we shift it off)
 * - Column 1: event type (e.g., "kill", "player_stat", "match_start")
 * - Remaining columns: event-specific data
 *
 * @param fileContent - Raw text content of the .txt log file
 * @returns Structured ParserData object with events categorized by type
 */
export function parseScrimLog(fileContent: string): ParserData {
  const lines = fileContent.split('\n').map((line) => line.split(','))

  // Remove first element of each array (the timestamp column)
  lines.forEach((line) => line.shift())

  // Clean invalid lines
  const cleanedLines = cleanInvalidLines(lines)

  // Categorize lines by event type
  const categorizedData: Record<string, (string | number | null)[][]> = {}

  cleanedLines.forEach((line) => {
    const eventType = line[0]
    if (headers[eventType]) {
      if (!categorizedData[eventType]) {
        categorizedData[eventType] = []
      }
      // Convert values to appropriate types
      const convertedLine = line.map((value, index) =>
        convertToNumberOrReplaceEmpty(value, eventType, index),
      )
      categorizedData[eventType].push(convertedLine)
    }
  })

  // Fix "All Teams" attacker entries (Echo dying during ult)
  if (categorizedData['kill']) {
    for (const kill of categorizedData['kill']) {
      if (kill[2] === 'All Teams') {
        kill[2] = kill[5] // Set attacker team to victim team
        kill[3] = kill[6] // Set attacker name to victim name
        kill[4] = kill[7] // Set attacker hero to victim hero
      }
    }
  }

  // Build the result — cast to ParserData since we know the shape
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
  const result = {} as ParserData

  for (const [eventType, rows] of Object.entries(categorizedData)) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ;(result as any)[eventType] = rows
  }

  return result
}

/**
 * Cleans invalid lines from the parsed data:
 * - Removes mercy_rez lines with null/empty fields
 * - Replaces asterisk values with "0"
 */
function cleanInvalidLines(lines: string[][]): string[][] {
  return lines
    .filter((line) => {
      if (line[0] === 'mercy_rez') {
        return !line.slice(1).some((field) => field === '' || field == null)
      }
      return true
    })
    .map((line) => {
      return line.map((field) => {
        if (field.includes('*')) {
          return '0'
        }
        return field
      })
    })
}

// Indexes for the 'kill' event type to skip parsing
const killSkipIndexes = {
  eventAbilityIndex: 8,
  criticalHitIndex: 10,
  environmentalIndex: 11,
}

/**
 * Map of event types to the column indexes that contain team name strings
 * (which should NOT be converted to numbers even if they look numeric).
 */
const teamNameFields: Record<string, number[]> = {
  defensive_assist: [2],
  dva_remech: [2],
  echo_duplicate_end: [2],
  echo_duplicate_start: [2],
  hero_spawn: [2],
  hero_swap: [2],
  kill: [2, 5],
  match_start: [4, 5],
  objective_captured: [3],
  offensive_assist: [2],
  payload_progress: [3],
  player_stat: [3],
  point_progress: [3],
  remech_charged: [2],
  ultimate_charged: [2],
  ultimate_end: [2],
  ultimate_start: [2],
  round_end: [3],
  round_start: [3],
}

function isTeamNameField(eventType: string, index: number): boolean {
  return teamNameFields[eventType]?.includes(index) || false
}

/**
 * Convert a CSV field value to its appropriate type:
 * - Empty strings → null
 * - Team name fields → kept as strings
 * - Kill ability/crit/environmental fields → kept as strings
 * - Numeric-looking values → parsed as numbers
 * - Everything else → kept as string
 */
function convertToNumberOrReplaceEmpty(
  value: string,
  eventType: string,
  index: number,
): string | number | null {
  if (value === '') {
    return null
  }

  // Handle round_end/round_start capturing_team field
  if (
    (eventType === 'round_end' || eventType === 'round_start') &&
    index === 3
  ) {
    if (value === '0') {
      return 0
    }
    return value
  }

  if (isTeamNameField(eventType, index)) {
    return value
  }

  if (
    eventType === 'kill' &&
    (index === killSkipIndexes.eventAbilityIndex ||
      index === killSkipIndexes.criticalHitIndex ||
      index === killSkipIndexes.environmentalIndex)
  ) {
    return value
  }

  const parsedValue = parseFloat(value)
  return isNaN(parsedValue) ? value : parsedValue
}

/**
 * Helper to convert a string to title case.
 */
export function toTitleCase(str: string): string {
  return str
    .toLowerCase()
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}
