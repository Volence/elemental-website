/**
 * ScrimTime log file parser.
 * Reads .txt CSV files generated by the ScrimTime workshop code and
 * converts them into structured ParserData objects.
 *
 * Ported from parsertime (MIT license) — adapted to remove xlsx dependency
 * and framework-specific code (NextAuth, Prisma imports). This is pure
 * data transformation with no side effects.
 */

import { headers } from './headers'
import type { ParserData } from './types'

/**
 * Parse a ScrimTime .txt log file into structured event data.
 *
 * The ScrimTime workshop code outputs CSV-formatted lines where:
 * - Column 0: timestamp (ignored — we shift it off)
 * - Column 1: event type (e.g., "kill", "player_stat", "match_start")
 * - Remaining columns: event-specific data
 *
 * @param fileContent - Raw text content of the .txt log file
 * @returns Structured ParserData object with events categorized by type
 */
export function parseScrimLog(fileContent: string): ParserData {
  const lines = fileContent.split('\n').map((line) => line.split(','))

  // Remove first element of each array (the timestamp column)
  lines.forEach((line) => line.shift())

  // Clean invalid lines
  const cleanedLines = cleanInvalidLines(lines)

  // Categorize lines by event type
  const categorizedData: Record<string, (string | number | null)[][]> = {}

  cleanedLines.forEach((line) => {
    const eventType = line[0]
    if (headers[eventType]) {
      if (!categorizedData[eventType]) {
        categorizedData[eventType] = []
      }
      // Convert values to appropriate types
      const convertedLine = line.map((value, index) =>
        convertToNumberOrReplaceEmpty(value, eventType, index),
      )
      categorizedData[eventType].push(convertedLine)
    }
  })

  // Fix "All Teams" attacker entries (Echo dying during ult)
  if (categorizedData['kill']) {
    for (const kill of categorizedData['kill']) {
      if (kill[2] === 'All Teams') {
        kill[2] = kill[5] // Set attacker team to victim team
        kill[3] = kill[6] // Set attacker name to victim name
        kill[4] = kill[7] // Set attacker hero to victim hero
      }
    }
  }

  // Build the result — cast to ParserData since we know the shape
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
  const result = {} as ParserData

  for (const [eventType, rows] of Object.entries(categorizedData)) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ;(result as any)[eventType] = rows
  }

  return result
}

/**
 * Cleans invalid lines from the parsed data:
 * - Removes mercy_rez lines with null/empty fields
 * - Replaces asterisk values with "0"
 */
function cleanInvalidLines(lines: string[][]): string[][] {
  return lines
    .filter((line) => {
      if (line[0] === 'mercy_rez') {
        return !line.slice(1).some((field) => field === '' || field == null)
      }
      return true
    })
    .map((line) => {
      return line.map((field) => {
        if (field.includes('*')) {
          return '0'
        }
        return field
      })
    })
}

// Indexes for the 'kill' event type to skip parsing
const killSkipIndexes = {
  eventAbilityIndex: 8,
  criticalHitIndex: 10,
  environmentalIndex: 11,
}

/**
 * Map of event types to the column indexes that contain team name strings
 * (which should NOT be converted to numbers even if they look numeric).
 */
const teamNameFields: Record<string, number[]> = {
  defensive_assist: [2],
  dva_remech: [2],
  echo_duplicate_end: [2],
  echo_duplicate_start: [2],
  hero_spawn: [2],
  hero_swap: [2],
  kill: [2, 5],
  match_start: [4, 5],
  objective_captured: [3],
  offensive_assist: [2],
  payload_progress: [3],
  player_stat: [3],
  point_progress: [3],
  remech_charged: [2],
  ultimate_charged: [2],
  ultimate_end: [2],
  ultimate_start: [2],
  round_end: [3],
  round_start: [3],
}

function isTeamNameField(eventType: string, index: number): boolean {
  return teamNameFields[eventType]?.includes(index) || false
}

/**
 * Convert a CSV field value to its appropriate type:
 * - Empty strings → null
 * - Team name fields → kept as strings
 * - Kill ability/crit/environmental fields → kept as strings
 * - Numeric-looking values → parsed as numbers
 * - Everything else → kept as string
 */
function convertToNumberOrReplaceEmpty(
  value: string,
  eventType: string,
  index: number,
): string | number | null {
  if (value === '') {
    return null
  }

  // Handle round_end/round_start capturing_team field
  if (
    (eventType === 'round_end' || eventType === 'round_start') &&
    index === 3
  ) {
    if (value === '0') {
      return 0
    }
    return value
  }

  if (isTeamNameField(eventType, index)) {
    return value
  }

  if (
    eventType === 'kill' &&
    (index === killSkipIndexes.eventAbilityIndex ||
      index === killSkipIndexes.criticalHitIndex ||
      index === killSkipIndexes.environmentalIndex)
  ) {
    return value
  }

  const parsedValue = parseFloat(value)
  return isNaN(parsedValue) ? value : parsedValue
}

/**
 * Helper to convert a string to title case.
 */
export function toTitleCase(str: string): string {
  return str
    .toLowerCase()
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
}
